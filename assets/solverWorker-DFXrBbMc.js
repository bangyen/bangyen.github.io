function k(l,g,u){return l*(u+1)+g}function W(l,g,u){const f=new Map,i=new Set;for(let o=0;o<g;o++)for(let r=0;r<u;r++){const h=l[o]?.[r];if(!h||h===0)continue;const c=h===1?k(o,r+1,u):k(o,r,u),e=h===1?k(o+1,r,u):k(o+1,r+1,u);f.has(c)||f.set(c,[]),f.has(e)||f.set(e,[]),f.get(c)?.push({node:e,r:o,c:r}),f.get(e)?.push({node:c,r:o,c:r})}const p=new Set,A=new Set,y=[],v=(o,r)=>{p.add(o),A.add(o);const h=f.get(o)??[];for(const{node:c,r:e,c:t}of h)if(c!==r)if(A.has(c)){i.add(`${e.toString()},${t.toString()}`);for(let n=y.length-1;n>=0;n--){const s=y[n];if(!s||(i.add(`${s.r.toString()},${s.c.toString()}`),s.u===c||s.v===c))break}}else p.has(c)||(y.push({r:e,c:t,u:o,v:c}),v(c,o),y.pop());A.delete(o)};for(const o of f.keys())p.has(o)||v(o,-1);return i}function M(l,g,u,f){const i=new Map,p=[],A=[];f.forEach((e,t)=>{i.set(t,{state:e,source:"user"});const[n,s]=t.split(",").map(Number);n!==void 0&&s!==void 0&&p.push({r:n,c:s})});const y=(e,t)=>{if(e<0||e>=l||t<0||t>=g)return 0;const n=`${e.toString()},${t.toString()}`;return i.get(n)?.state??0},v=(e,t,n,s)=>{const a=`${e.toString()},${t.toString()}`,R=i.get(a);if(R){R.state!==n&&A.push({type:"cell",r:e,c:t});return}i.set(a,{state:n,source:s}),p.push({r:e,c:t})},o=(e,t)=>[{r:e-1,c:t-1,required:2},{r:e-1,c:t,required:1},{r:e,c:t-1,required:1},{r:e,c:t,required:2}].filter(n=>n.r>=0&&n.r<l&&n.c>=0&&n.c<g);let r=0;for(;r<p.length;){const e=p[r++];if(!e)break;const{r:t,c:n}=e,s=[{r:t,c:n},{r:t,c:n+1},{r:t+1,c:n},{r:t+1,c:n+1}];for(const a of s){const R=u[a.r]?.[a.c];if(R==null)continue;const D=o(a.r,a.c);let C=0;const S=[];for(const d of D){const b=y(d.r,d.c);b===0?S.push(d):b===d.required&&C++}if(C>R){A.push({type:"node",r:a.r,c:a.c});continue}if(C+S.length<R){A.push({type:"node",r:a.r,c:a.c});continue}if(i.get(`${t.toString()},${n.toString()}`)?.source==="user"){if(C===R&&S.length>0)for(const d of S){const b=d.required===1?2:1;v(d.r,d.c,b,"propagated")}else if(C+S.length===R&&S.length>0)for(const d of S)v(d.r,d.c,d.required,"propagated")}}}const h=Array.from({length:l},()=>new Array(g).fill(0));for(const[e,t]of i.entries()){const[n,s]=e.split(",").map(Number);n!==void 0&&s!==void 0&&h[n]&&(h[n][s]=t.state)}const c=W(h,l,g);return{gridState:i,conflicts:A,cycleCells:c}}globalThis.onmessage=l=>{if(l.data.type==="SOLVE"){const{rows:g,cols:u,numbers:f,userMoves:i}=l.data.payload,p=M(g,u,f,i);self.postMessage({type:"RESULT",payload:p})}};
