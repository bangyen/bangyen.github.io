function n(n){if(1===n)return[1n];const t=[7n<<BigInt(n-2)];for(let r=1;r<n;r++){const n=t[r-1];if(void 0!==n){const o=n>>1n;t.push(o)}}const o=t[0];return void 0!==o&&(t[0]=o-(1n<<BigInt(n))),t}function t(n,t){const o=n.length,r=[];for(let e=0;e<o;e++){const i=n[e];let s=0n;if(void 0!==i)for(let n=0;n<o;n++)if(i&1n<<BigInt(o-1-n)){const o=t[n];void 0!==o&&(s^=o)}r.push(s)}return r}function o(n){const t=Array(n).fill(1n);for(let o=0;o<n;o++){const r=t[o];void 0!==r&&(t[o]=r<<BigInt(n-o-1))}return t}function r(n,r,e){let i=o(n.length),s=[...n],f=r;for(;f>0;)f%2==1&&(i=t(i,s)),s=t(s,s),f=Math.floor(f/2);return i}function e(n,t){const o=n.length,r=[];for(let e=0;e<o;e++){const o=n[e],i=t[e];if(void 0!==o&&void 0!==i){const n=o^i;r.push(n)}}return r}function i(n){const t=o(n.length);return n.every((n,o)=>n===t[o])}function s(n){return n.every(n=>0n===n)}function f(n){const t={0:"⁰",1:"¹",2:"²",3:"³",4:"⁴",5:"⁵",6:"⁶",7:"⁷",8:"⁸",9:"⁹"};return n.toString().split("").map(n=>t[n]??n).join("")}function c(n){if(0n===n)return"0";if(1n===n)return"1";const t=[],o=n.toString(2);for(let r=0;r<o.length;r++)"1"===o[o.length-1-r]&&(0===r?t.push("1"):1===r?t.push("x"):t.push(`x${f(r)}`));return t.reverse().join(" + ")}function u(n){const t=[0n,1n];for(let o=1;o<n;o++){const n=t[o],r=t[o-1];if(void 0!==n&&void 0!==r){const o=n<<1n;t.push(o^r)}}return t[n]??0n}function l(n){return 0n===n?-1:n.toString(2).length-1}function h(n,t){if(0n===t)throw new Error("Division by zero polynomial");let o=0n,r=n;const e=l(t);for(;l(r)>=e;){const n=l(r)-e;o^=1n<<BigInt(n),r^=t<<BigInt(n)}return{quotient:o,remainder:r}}function g(n,t){return h(n,t).remainder}function p(n,t,o){const i=n.length;let s=Array(i).fill(0n),f=0,c=t;for(;c>0n;){if(1n&c){s=e(s,r(n,f))}c>>=1n,f++}return s}const a=[2n,3n];let d=1;function v(n){if(0n===n)return[];if(1n===n)return[];const t=[];let o=n;const r=function(n){if(n<=d)return a.filter(t=>l(t)<=n);for(let t=1n<<BigInt(d+1);l(t)<=n;t++){let n=!0;const o=l(t);for(const r of a){if(l(r)>o/2)break;if(0n===g(t,r)){n=!1;break}}n&&a.push(t)}return d=n,a}(l(n));for(const e of r){if(0n===g(o,e)){let n=0;for(;0n===g(o,e);)o=h(o,e).quotient,n++;t.push({factor:e,exponent:n})}if(1n===o)break}return t}function m(n,t){for(const o of function(n){const t=[];for(let o=1;o<=Math.sqrt(n);o++)n%o===0&&(t.push(o),o!==n/o&&t.push(n/o));return t.sort((n,t)=>n-t)}(n)){if(1===o||o===n)continue;const r=t.map(n=>n%o).filter((n,t,o)=>o.indexOf(n)===t).sort((n,t)=>n-t),e=[];for(let t=0;t<n;t++)r.includes(t%o)&&e.push(t);if(JSON.stringify(t)===JSON.stringify(e)&&r.length<t.length)return m(o,r)}return{z:n,R:t}}self.onmessage=t=>{const{n:r}=t.data;try{const t=function(t){const r=n(t),e=o(t),f=Array.from({length:t},()=>0n),c=[];for(let n=0;n<t;n++){const o=[],e=r[n];if(void 0!==e)for(let n=0;n<t;n++)e&1n<<BigInt(t-1-n)&&o.push(n);c.push(o)}let u=[...f],l=[...e];const h=[0];for(let n=2;n<=1e7;n++){const o=[];for(let n=0;n<t;n++){let t=u[n]??0n;const r=c[n];if(r)for(const n of r){const o=l[n];void 0!==o&&(t^=o)}o.push(t)}if(i(o)&&h.push(n-1),i(o)&&s(l)){const o=n-1,r=h.filter(n=>n!==o),{z:e,R:i}=m(o,r);return{n:t,z:e,R:i,z_seq:o}}u=l,l=o}throw new Error(`Period not found for n=${t.toString()}`)}(r),e=function(n){const t=n.length;function o(n){let o=0n;for(const r of n)o=o<<BigInt(t)|r;return o}const r=[];for(let e=0;e<=t*t;e++){const t=1n<<BigInt(e);let i=o(p(n,t)),s=t;for(const n of r)l(i^n.vector)<l(i)&&(i^=n.vector,s^=n.poly);if(0n===i)return s;r.push({vector:i,poly:s}),r.sort((n,t)=>n.vector>t.vector?-1:1)}return u(t+1)}(n(r)),h=v(e),a=u(t.z_seq),d=u(t.z_seq+1),y=g(a,e),q=g(1n^d,e),x={pattern:t,minimalPoly:c(e),factorization:h.map(n=>`(${c(n.factor)})${n.exponent>1?f(n.exponent):""}`).join(" · "),proof:{eq1:`f${f(t.z_seq)}(x) mod M(x)`,res1:c(y),eq2:`(f${f(t.z_seq+1)}(x) + 1) mod M(x)`,res2:c(q)}};self.postMessage({success:!0,result:x})}catch(e){self.postMessage({success:!1,error:e instanceof Error?e.message:"Unknown error occurred in worker"})}};
