!function(){"use strict";function n(n){if(1===n)return[1n];const t=[7n<<BigInt(n-2)];for(let r=1;r<n;r++){const n=t[r-1];if(void 0!==n){const o=n>>1n;t.push(o)}}const o=t[0];return void 0!==o&&(t[0]=o-(1n<<BigInt(n))),t}function t(n){const t={0:"⁰",1:"¹",2:"²",3:"³",4:"⁴",5:"⁵",6:"⁶",7:"⁷",8:"⁸",9:"⁹"};return n.toString().split("").map(n=>t[n]??n).join("")}function o(n){if(0n===n)return"0";if(1n===n)return"1";const o=[],r=n.toString(2);for(let e=0;e<r.length;e++)"1"===r[r.length-1-e]&&(0===e?o.push("1"):1===e?o.push("x"):o.push(`x${t(e)}`));return o.reverse().join(" + ")}function r(n,t){const o=n.length,r=[];for(let e=0;e<o;e++){const i=n[e];let s=0n;if(void 0!==i)for(let n=0;n<o;n++)if(i&1n<<BigInt(o-1-n)){const o=t[n];void 0!==o&&(s^=o)}r.push(s)}return r}function e(n){const t=Array(n).fill(1n);for(let o=0;o<n;o++){const r=t[o];void 0!==r&&(t[o]=r<<BigInt(n-o-1))}return t}function i(n,t,o){let i=e(n.length),s=[...n],f=t;for(;f>0;)f%2==1&&(i=r(i,s)),s=r(s,s),f=Math.floor(f/2);return i}function s(n,t){const o=n.length,r=[];for(let e=0;e<o;e++){const o=n[e],i=t[e];if(void 0!==o&&void 0!==i){const n=o^i;r.push(n)}}return r}function f(n){const t=[0n,1n];for(let o=1;o<n;o++){const n=t[o],r=t[o-1];if(void 0!==n&&void 0!==r){const o=n<<1n;t.push(o^r)}}return t[n]??0n}function c(n){return 0n===n?-1:n.toString(2).length-1}function u(n,t){if(0n===t)throw new Error("Division by zero polynomial");let o=0n,r=n;const e=c(t);for(;c(r)>=e;){const n=c(r)-e;o^=1n<<BigInt(n),r^=t<<BigInt(n)}return{quotient:o,remainder:r}}function l(n,t){return u(n,t).remainder}const h=[2n,3n];let g=1;function p(n){if(0n===n)return[];if(1n===n)return[];const t=[];let o=n;const r=function(n){if(n<=g)return h.filter(t=>c(t)<=n);for(let t=1n<<BigInt(g+1);c(t)<=n;t++){let n=!0;const o=c(t);for(const r of h){if(c(r)>o/2)break;if(0n===l(t,r)){n=!1;break}}n&&h.push(t)}return g=n,h}(c(n));for(const e of r){if(0n===l(o,e)){let n=0;for(;0n===l(o,e);)o=u(o,e).quotient,n++;t.push({factor:e,exponent:n})}if(1n===o)break}return t}function a(n,t,o){const r=n.length;let e=Array(r).fill(0n),f=0,c=t;for(;c>0n;){if(1n&c){e=s(e,i(n,f))}c>>=1n,f++}return e}function d(n){const t=e(n.length);return n.every((n,o)=>n===t[o])}function v(n){return n.every(n=>0n===n)}function m(n,t){for(const o of function(n){const t=[];for(let o=1;o<=Math.sqrt(n);o++)n%o===0&&(t.push(o),o!==n/o&&t.push(n/o));return t.sort((n,t)=>n-t)}(n)){if(1===o||o===n)continue;const r=t.map(n=>n%o).filter((n,t,o)=>o.indexOf(n)===t).sort((n,t)=>n-t),e=[];for(let t=0;t<n;t++)r.includes(t%o)&&e.push(t);if(JSON.stringify(t)===JSON.stringify(e)&&r.length<t.length)return m(o,r)}return{z:n,R:t}}self.onmessage=r=>{const{n:i}=r.data;try{const r=function(t){const o=n(t),r=e(t),i=Array.from({length:t},()=>0n),s=[];for(let n=0;n<t;n++){const r=[],e=o[n];if(void 0!==e)for(let n=0;n<t;n++)e&1n<<BigInt(t-1-n)&&r.push(n);s.push(r)}let f=[...i],c=[...r];const u=[0];for(let n=2;n<=1e7;n++){const o=[];for(let n=0;n<t;n++){let t=f[n]??0n;const r=s[n];if(r)for(const n of r){const o=c[n];void 0!==o&&(t^=o)}o.push(t)}if(d(o)&&u.push(n-1),d(o)&&v(c)){const o=n-1,r=u.filter(n=>n!==o),{z:e,R:i}=m(o,r);return{n:t,z:e,R:i,z_seq:o}}f=c,c=o}throw new Error(`Period not found for n=${t.toString()}`)}(i),s=function(n){const t=n.length;function o(n){let o=0n;for(const r of n)o=o<<BigInt(t)|r;return o}const r=[];for(let e=0;e<=t*t;e++){const t=1n<<BigInt(e);let i=o(a(n,t)),s=t;for(const n of r)c(i^n.vector)<c(i)&&(i^=n.vector,s^=n.poly);if(0n===i)return s;r.push({vector:i,poly:s}),r.sort((n,t)=>n.vector>t.vector?-1:1)}return f(t+1)}(n(i)),u=p(s),h=f(r.z_seq),g=f(r.z_seq+1),y=l(h,s),q=l(1n^g,s),x={pattern:r,minimalPoly:o(s),factorization:u.map(n=>`(${o(n.factor)})${n.exponent>1?t(n.exponent):""}`).join(" · "),proof:{eq1:`f${t(r.z_seq)}(x) mod M(x)`,res1:o(y),eq2:`(f${t(r.z_seq+1)}(x) + 1) mod M(x)`,res2:o(q)}};self.postMessage({success:!0,result:x})}catch(s){self.postMessage({success:!1,error:s instanceof Error?s.message:"Unknown error occurred in worker"})}}}();
